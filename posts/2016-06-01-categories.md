---
title: Categories in Theory and in Haskell 
author: Ben Kovach
tags: haskell, category-theory
---

## Overview

This is the first post in a series that I hope to expand over time regarding
notions in Category theory and how they manifest in the Haskell programming
language.

Category theory is extremely general; It's language is useful
in recognizing structure and unifying mathematical
concepts that don't seem related at first glance. It's a wonderful tool for
gaining intuition about wildly different things in one fell swoop, which makes
it a lot of fun to explore.

On the other hand, haskell is an increasingly-widely-used, purely functional
programming language based on category theory. A lot of the bizarre-sounding words
haskellers use on a daily basis are rooted in category theory (or other branches of
mathematics that category theory generalizes). However, mapping from category
theory to Haskell is sometimes nontrivial. 

I think that learning haskell should be a tool for understanding
category theory and vice versa. I hope to shed some light on the explicit
mappings between category theoretical concepts and their haskell counterparts in
this series.

## The category (intuitively)

A category is a type of mathematical object. For the uninitiated, one of the
simplest examples of a mathematical object is the `Set`; a collection of
"things" that doesn't contain duplicates. Examples are:

- The set of Natural numbers ($\{0..\infty\}$)
- The set of all humans living in Europe
- The set of all board games designed in the 1980s.

Sets have very little structure, so studying how they interact isn't very interesting.
Many traditional mathematical structures add structure _on top of_ sets in order to find more interesting insights.

A category* is one of these abstractions. Intuitively, a category encodes a
structure containing a bunch of "things" and ways to move between those things.

<small>
\* Technically, _small_ category.
</small>

## The Category (In Theory)

The (semi)formal* definition of a category is as follows:

A category C consists of two things:

- A collection $C_0$ of _objects_
- A collection $C_1$ of _morphisms_, with a *source* and *target* in $C_0$. We'll
  consider an element of this set to look like `f : a -> b`, where `a` is the
  source, and `b` is the target.
- A special morphism in $C_1$ called $id$, which follows the left and right unit laws listed
  below. 
- A composition operator $\circ$, which assigns, to any pair of morphisms `f : a
  -> b` and `g : b -> c`, a composite morphism $g \circ f$ `: a -> c`.

The following are also necessarily true of a category:

- Composition is associative: $(h \circ g) \circ f = h \circ (g \circ f)$ for `f :
  a -> b, g : b -> c, h : c -> d` in $C_0$.
- Composition satisfies the left and right unit laws: $id_y \circ f = f = f
  \circ id_x$ for all morphisms $s$ in $C_0$.

Intuitively, $id$ maps each object back to itself. However, when the structure
of a category's morphisms doesn't look like a _pure function_, this definition
is not sufficient. Neither the structure of objects, nor the structure of morphisms,
is static across all categories. Hence we cannot say exactly what $id$ or
$\circ$ _does_; we can only say how they should behave when they appear
together in a mathematical expression.

<small>
\* Slightly handwavy, but formal enough to get the point across for our purposes!
  For two _full_ definitions, see [nlab's page on categories](https://ncatlab.org/nlab/show/category#definitions).
</small>


Here's an example:

**Set** is the category consisting of Sets as objects and functions between
those sets as morphisms. Two objects in this category are the set of Natural
numbers $\mathbb{N}$ and the set of Boolean values $Bool = \{True, False\}$.
The function `odd : N -> Bool` which takes each natural number to its truth
value of whether it is odd or not a morphism in this Category.

Some other examples of categories are:

- The **free category** generated by a directed graph, with nodes as objects and arrows
  between nodes as morphisms.
- **Hask**, the Category of Haskell types and functions, which we will discuss
  next. 
- **Grp**, the category with groups as objects and group homomorphisms as arrows.*

<small>
* It's hard to find examples that aren't deeply entrenched in mathematics;
  sorry!
</small>

## Hask

Before we talk about _encoding_ categories in Haskell, I'd like to briefly talk about
Haskell's very own category, **Hask**.

**Hask** is the category in which:

- Members of Haskell's types are objects
- Regular Haskell functions (`a -> b`)  are morphisms.

`id :: a -> a` is the $id$ morphism, and regular function
composition with `(.) :: (b -> c) -> (a -> b) -> (a -> c)` is morphism
composition in **Hask**. 

**Hask** is a legitimate category, but we have to be specific about what `undefined` means.
More on that [on haskell wiki](https://wiki.haskell.org/Hask).

## The category (in haskell)

So how do we encode categories in haskell? We typically use
typeclasses to encode common functionality between various structures, which is
exactly what we will do here.

```haskell
class Category cat where
  id : cat a a
  (.) : cat b c -> cat a b -> cat a c 
```

We'll talk more about this in a minute. First, let's look at the simplest
example of this category, the instance for `(->)` (You can turn on the
`InstanceSigs` GHC extension to get these to compile):

```haskell
instance Category (->) where
  id :: a -> a -- or (->) a a
  id x = x

  (.) :: (b -> c) -> (a -> b) -> (a -> c)
      -- or ((->) b c) -> ((->) a b) -> ((->) a c)
  (f . g) x = f (g x) 
```

This instance encodes **Hask**. Another common `Category` instance we encounter often as haskell
programmers daily is the one for `Kleisli` arrows:

```haskell
newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }

instance Monad m => Kleisli m where
  id :: Kleisli m a b 
  id = Kleisli return

  (.) :: Kleisli m b c -> Kleisli m a b -> Kleisli m a c
  (Kleisli f . Kleisli g) = Kleisli $ \x -> (f <=< g) x
```

Recall that:

```haskell
return :: Monad m => a -> m a 
(<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
```

and it might be easier to see where that instance comes from. I won't 
prove that these two instances follow the category laws here; the important
thing for our purposes is that our instances follow the pattern.

At this point, it may feel like there are some holes. In the
mathematical interpretation, we're constructing categories by explicitly
providing both _objects_ of a category and the structure of its _morphisms_;
identity and composition come later. So, where's the connection?

## The connection

Objects of a `Category` in haskell are types. The typeclass variable `cat`
describes the structure of morphisms in our category. Specifically, the sources
and targets of our morphisms are hidden in the type declaration for the
morphisms we're declaring a category instance for. In `(->)`, the source and
target can be any haskell data type. For a morphism in `Kleisli`, however, the _source_ can be
any haskell data type, but the _target_ of our morphisms must be something with the structure `m
a` for some `m`. This lets us describe in some sense the structure of a morphism
in the category, though it does not give us all laws for free (Try encoding
**Grp**, for instance).

In typeclass instances for `Category`, we develop the
laws stating that we must have identity and composition operators that respect the
structure of our objects and categories. Haskell's typechecker helps us confirm
that some of the category laws hold by construction. If we can't find something
of type `cat a a`, we don't have an $id$. If we can't find a typechecking
instance for `(.)`, we can't ensure that sources and targets match up when
composing morphisms. This may not always give us law-abiding instances for free,
but we can certainly be guided by the typechecker.

<hr />

### Aside: types

Types are themselves a kind of mathematical structure in the same vein as sets.
The main difference is that types are _constrained_ to a certain subset of
values; with (mathematical) sets, anything goes. Haskell's type definitions
define a subset of _values_ that are valid inhabitants (members) of a
type. The type itself can be viewed in some sense as the set of all of its inhabitants.
When we say a value $v$ has type $\tau$, with this definition we are saying that $v \in \tau$.

<hr />

(These are not the only categories we can encode in Haskell; they are just two common
examples.)

## Takeaway

It is possible to encode a category in haskell, but it doesn't look exactly the
same as laying out its definition on paper in a mathematical setting. In particular:

- A category $C$ is defined in haskell by providing the type of morphisms in
  $C$, instead of explicitly stating its objects and morphisms.
- Objects of all categories defined in haskell are types. In the whole world of
  mathematics, objects can be much broader.
- $id$ and $\circ$ are provided for all Category instances, and must typecheck,
  which helps us find law-abiding implementations.

